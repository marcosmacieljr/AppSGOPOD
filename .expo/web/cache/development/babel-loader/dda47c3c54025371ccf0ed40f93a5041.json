{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"/Users/satya/Workspace/Callstack/react-navigation-stack/src/views/Transitioner.tsx\";\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport NavigationScenesReducer from \"./ScenesReducer\";\nvar DefaultTransitionSpec = {\n  duration: 250,\n  easing: Easing.inOut(Easing.ease),\n  timing: Animated.timing\n};\n\nvar Transitioner = function (_React$Component) {\n  _inherits(Transitioner, _React$Component);\n\n  function Transitioner(_props) {\n    var _this;\n\n    _classCallCheck(this, Transitioner);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Transitioner).call(this, _props));\n\n    _this.computeScenes = function (props, nextProps) {\n      var nextScenes = NavigationScenesReducer(_this.state.scenes, nextProps.navigation.state, props.navigation.state, nextProps.descriptors);\n\n      if (!nextProps.navigation.state.isTransitioning) {\n        nextScenes = filterStale(nextScenes);\n      }\n\n      if (nextProps.screenProps !== _this.props.screenProps) {\n        _this.setState({\n          nextScenes: nextScenes\n        });\n      }\n\n      if (nextScenes === _this.state.scenes) {\n        return;\n      }\n\n      return nextScenes;\n    };\n\n    _this.handleLayout = function (event) {\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n          height = _event$nativeEvent$la.height,\n          width = _event$nativeEvent$la.width;\n\n      if (_this.state.layout.initWidth === width && _this.state.layout.initHeight === height) {\n        return;\n      }\n\n      var layout = _objectSpread({}, _this.state.layout, {\n        initHeight: height,\n        initWidth: width,\n        isMeasured: true\n      });\n\n      layout.height.setValue(height);\n      layout.width.setValue(width);\n\n      var nextState = _objectSpread({}, _this.state, {\n        layout: layout\n      });\n\n      _this.transitionProps = buildTransitionProps(_this.props, nextState);\n\n      _this.setState(nextState);\n    };\n\n    _this.handleTransitionEnd = function () {\n      if (!_this.isComponentMounted) {\n        return;\n      }\n\n      var prevTransitionProps = _this.prevTransitionProps;\n      _this.prevTransitionProps = undefined;\n      var scenes = filterStale(_this.state.scenes);\n\n      var nextState = _objectSpread({}, _this.state, {\n        scenes: scenes\n      });\n\n      _this.transitionProps = buildTransitionProps(_this.props, nextState);\n\n      _this.setState(nextState, function _callee() {\n        var result, prevProps;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!_this.props.onTransitionEnd) {\n                  _context.next = 5;\n                  break;\n                }\n\n                result = _this.props.onTransitionEnd(_this.transitionProps, prevTransitionProps);\n\n                if (!(result instanceof Promise)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 5;\n                return _regeneratorRuntime.awrap(result);\n\n              case 5:\n                if (_this.queuedTransition) {\n                  prevProps = _this.queuedTransition.prevProps;\n                  _this.queuedTransition = null;\n\n                  _this.startTransition(prevProps, _this.props);\n                } else {\n                  _this.isTransitionRunning = false;\n                }\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        });\n      });\n    };\n\n    var _layout = {\n      height: new Animated.Value(0),\n      initHeight: 0,\n      initWidth: 0,\n      isMeasured: false,\n      width: new Animated.Value(0)\n    };\n    var position = new Animated.Value(_this.props.navigation.state.index);\n    _this.positionListener = position.addListener(function () {});\n    _this.state = {\n      layout: _layout,\n      position: position,\n      scenes: NavigationScenesReducer([], _this.props.navigation.state, null, _this.props.descriptors)\n    };\n    _this.prevTransitionProps = undefined;\n    _this.transitionProps = buildTransitionProps(_props, _this.state);\n    _this.isComponentMounted = false;\n    _this.isTransitionRunning = false;\n    _this.queuedTransition = null;\n    return _this;\n  }\n\n  _createClass(Transitioner, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.isComponentMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.isComponentMounted = false;\n      this.positionListener && this.state.position.removeListener(this.positionListener);\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      if (this.isTransitionRunning) {\n        if (!this.queuedTransition) {\n          this.queuedTransition = {\n            prevProps: this.props\n          };\n        }\n\n        return;\n      }\n\n      this.startTransition(this.props, nextProps);\n    }\n  }, {\n    key: \"startTransition\",\n    value: function startTransition(props, nextProps) {\n      var _this2 = this;\n\n      var indexHasChanged = props.navigation.state.index !== nextProps.navigation.state.index;\n      var nextScenes = this.computeScenes(props, nextProps);\n\n      if (!nextScenes) {\n        this.prevTransitionProps = this.transitionProps;\n        this.state.position.setValue(props.navigation.state.index);\n        this.handleTransitionEnd();\n        return;\n      }\n\n      var nextState = _objectSpread({}, this.state, {\n        scenes: nextScenes\n      });\n\n      var position = nextState.position;\n      var toValue = nextProps.navigation.state.index;\n      this.prevTransitionProps = this.transitionProps;\n      this.transitionProps = buildTransitionProps(nextProps, nextState);\n      var isTransitioning = this.transitionProps.navigation.state.isTransitioning;\n\n      if (!isTransitioning || !indexHasChanged) {\n        this.setState(nextState, function _callee2() {\n          var result;\n          return _regeneratorRuntime.async(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!nextProps.onTransitionStart) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  result = nextProps.onTransitionStart(_this2.transitionProps, _this2.prevTransitionProps);\n\n                  if (!(result instanceof Promise)) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  _context2.next = 5;\n                  return _regeneratorRuntime.awrap(result);\n\n                case 5:\n                  indexHasChanged && position.setValue(toValue);\n\n                  _this2.handleTransitionEnd();\n\n                case 7:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          });\n        });\n      } else if (isTransitioning) {\n        this.isTransitionRunning = true;\n        this.setState(nextState, function _callee3() {\n          var result, transitionUserSpec, transitionSpec, timing, positionHasChanged;\n          return _regeneratorRuntime.async(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!nextProps.onTransitionStart) {\n                    _context3.next = 5;\n                    break;\n                  }\n\n                  result = nextProps.onTransitionStart(_this2.transitionProps, _this2.prevTransitionProps);\n\n                  if (!(result instanceof Promise)) {\n                    _context3.next = 5;\n                    break;\n                  }\n\n                  _context3.next = 5;\n                  return _regeneratorRuntime.awrap(result);\n\n                case 5:\n                  transitionUserSpec = nextProps.configureTransition ? nextProps.configureTransition(_this2.transitionProps, _this2.prevTransitionProps) : null;\n                  transitionSpec = _objectSpread({}, DefaultTransitionSpec, transitionUserSpec);\n                  timing = transitionSpec.timing;\n                  delete transitionSpec.timing;\n                  positionHasChanged = position.__getValue() !== toValue;\n\n                  if (indexHasChanged && positionHasChanged) {\n                    timing(position, _objectSpread({}, transitionSpec, {\n                      toValue: nextProps.navigation.state.index\n                    })).start(function () {\n                      requestAnimationFrame(_this2.handleTransitionEnd);\n                    });\n                  } else {\n                    _this2.handleTransitionEnd();\n                  }\n\n                case 11:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          });\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(View, {\n        onLayout: this.handleLayout,\n        style: styles.main,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 267\n        }\n      }, this.props.render(this.transitionProps, this.prevTransitionProps));\n    }\n  }]);\n\n  return Transitioner;\n}(React.Component);\n\nfunction buildTransitionProps(props, state) {\n  var navigation = props.navigation;\n  var layout = state.layout,\n      position = state.position,\n      scenes = state.scenes;\n  var scene = scenes.find(isSceneActive);\n\n  if (!scene) {\n    throw new Error('Could not find active scene');\n  }\n\n  return {\n    layout: layout,\n    navigation: navigation,\n    position: position,\n    scenes: scenes,\n    scene: scene,\n    index: scene.index\n  };\n}\n\nfunction isSceneNotStale(scene) {\n  return !scene.isStale;\n}\n\nfunction filterStale(scenes) {\n  var filtered = scenes.filter(isSceneNotStale);\n\n  if (filtered.length === scenes.length) {\n    return scenes;\n  }\n\n  return filtered;\n}\n\nfunction isSceneActive(scene) {\n  return scene.isActive;\n}\n\nvar styles = StyleSheet.create({\n  main: {\n    flex: 1\n  }\n});\nexport default Transitioner;","map":{"version":3,"mappings":"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","names":["React","NavigationScenesReducer","DefaultTransitionSpec","duration","easing","Easing","inOut","ease","timing","Animated","Transitioner","props","_classCallCheck","_this","computeScenes","nextProps","nextScenes","state","scenes","navigation","descriptors","isTransitioning","filterStale","screenProps","setState","handleLayout","event","nativeEvent","layout","height","width","initWidth","initHeight","isMeasured","setValue","nextState","transitionProps","buildTransitionProps","handleTransitionEnd","isComponentMounted","prevTransitionProps","undefined","onTransitionEnd","_context","result","Promise","queuedTransition","prevProps","startTransition","isTransitionRunning","Value","position","index","positionListener","addListener","removeListener","indexHasChanged","toValue","onTransitionStart","_context2","_this2","_context3","transitionUserSpec","configureTransition","transitionSpec","positionHasChanged","__getValue","start","requestAnimationFrame","View","onLayout","style","styles","main","__source","fileName","lineNumber","render","Component","scene","find","isSceneActive","Error","isSceneNotStale","isStale","filtered","filter","length","isActive","StyleSheet","create","flex"],"sources":["Transitioner.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  Easing,\n  StyleSheet,\n  View,\n  LayoutChangeEvent,\n} from 'react-native';\n\nimport NavigationScenesReducer from './ScenesReducer';\nimport {\n  NavigationStackProp,\n  Scene,\n  SceneDescriptorMap,\n  TransitionerLayout,\n  TransitionProps,\n} from '../types';\n\ntype TransitionSpec = {};\n\ntype Props = {\n  render: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => React.ReactNode;\n  configureTransition?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => TransitionSpec;\n  onTransitionStart?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => void | Promise<any>;\n  onTransitionEnd?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => void | Promise<any>;\n  navigation: NavigationStackProp;\n  descriptors: SceneDescriptorMap;\n  screenProps?: unknown;\n};\n\ntype State = {\n  layout: TransitionerLayout;\n  position: Animated.Value;\n  scenes: Scene[];\n  nextScenes?: Scene[];\n};\n\n// Used for all animations unless overriden\nconst DefaultTransitionSpec = {\n  duration: 250,\n  easing: Easing.inOut(Easing.ease),\n  timing: Animated.timing,\n};\n\nclass Transitioner extends React.Component<Props, State> {\n  private positionListener: string;\n\n  private prevTransitionProps: TransitionProps | undefined;\n  private transitionProps: TransitionProps;\n\n  private isComponentMounted: boolean;\n  private isTransitionRunning: boolean;\n  private queuedTransition: { prevProps: Props } | null;\n\n  constructor(props: Props) {\n    super(props);\n\n    // The initial layout isn't measured. Measured layout will be only available\n    // when the component is mounted.\n    const layout: TransitionerLayout = {\n      height: new Animated.Value(0),\n      initHeight: 0,\n      initWidth: 0,\n      isMeasured: false,\n      width: new Animated.Value(0),\n    };\n\n    const position = new Animated.Value(this.props.navigation.state.index);\n    this.positionListener = position.addListener((/* { value } */) => {\n      // This should work until we detach position from a view! so we have to be\n      // careful to not ever detach it, thus the gymnastics in _getPosition in\n      // StackViewLayout\n      // This should log each frame when releasing the gesture or when pressing\n      // the back button! If not, something has gone wrong with the animated\n      // value subscription\n      // console.log(value);\n    });\n\n    this.state = {\n      layout,\n      position,\n      scenes: NavigationScenesReducer(\n        [],\n        this.props.navigation.state,\n        null,\n        this.props.descriptors\n      ),\n    };\n\n    this.prevTransitionProps = undefined;\n    this.transitionProps = buildTransitionProps(props, this.state);\n\n    this.isComponentMounted = false;\n    this.isTransitionRunning = false;\n    this.queuedTransition = null;\n  }\n\n  componentDidMount() {\n    this.isComponentMounted = true;\n  }\n\n  componentWillUnmount() {\n    this.isComponentMounted = false;\n    this.positionListener &&\n      this.state.position.removeListener(this.positionListener);\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    if (this.isTransitionRunning) {\n      if (!this.queuedTransition) {\n        this.queuedTransition = { prevProps: this.props };\n      }\n      return;\n    }\n\n    this.startTransition(this.props, nextProps);\n  }\n\n  private computeScenes = (props: Props, nextProps: Props) => {\n    let nextScenes = NavigationScenesReducer(\n      this.state.scenes,\n      nextProps.navigation.state,\n      props.navigation.state,\n      nextProps.descriptors\n    );\n\n    if (!nextProps.navigation.state.isTransitioning) {\n      nextScenes = filterStale(nextScenes);\n    }\n\n    // Update nextScenes when we change screenProps\n    // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n    if (nextProps.screenProps !== this.props.screenProps) {\n      this.setState({ nextScenes });\n    }\n\n    if (nextScenes === this.state.scenes) {\n      return;\n    }\n\n    return nextScenes;\n  };\n\n  private startTransition(props: Props, nextProps: Props) {\n    const indexHasChanged =\n      props.navigation.state.index !== nextProps.navigation.state.index;\n    let nextScenes = this.computeScenes(props, nextProps);\n\n    if (!nextScenes) {\n      // prevTransitionProps are the same as transitionProps in this case\n      // because nothing changed\n      this.prevTransitionProps = this.transitionProps;\n\n      // Unsure if this is actually a good idea... Also related to\n      // https://github.com/react-navigation/react-navigation/issues/5247\n      // - the animation is interrupted before completion so this ensures\n      // that it is properly set to the final position before firing\n      // onTransitionEnd\n      this.state.position.setValue(props.navigation.state.index);\n\n      this.handleTransitionEnd();\n      return;\n    }\n\n    const nextState = {\n      ...this.state,\n      scenes: nextScenes,\n    };\n\n    // grab the position animated value\n    const { position } = nextState;\n\n    // determine where we are meant to transition to\n    const toValue = nextProps.navigation.state.index;\n\n    // compute transitionProps\n    this.prevTransitionProps = this.transitionProps;\n    this.transitionProps = buildTransitionProps(nextProps, nextState);\n    let { isTransitioning } = this.transitionProps.navigation.state;\n\n    // if the state isn't transitioning that is meant to signal that we should\n    // transition immediately to the new index. if the index hasn't changed, do\n    // the same thing here. it's not clear to me why we ever start a transition\n    // when the index hasn't changed, this requires further investigation.\n    if (!isTransitioning || !indexHasChanged) {\n      this.setState(nextState, async () => {\n        if (nextProps.onTransitionStart) {\n          const result = nextProps.onTransitionStart(\n            this.transitionProps,\n            this.prevTransitionProps\n          );\n          if (result instanceof Promise) {\n            // why do we bother awaiting the result here?\n            await result;\n          }\n        }\n        // jump immediately to the new value\n        indexHasChanged && position.setValue(toValue);\n        // end the transition\n        this.handleTransitionEnd();\n      });\n    } else if (isTransitioning) {\n      this.isTransitionRunning = true;\n      this.setState(nextState, async () => {\n        if (nextProps.onTransitionStart) {\n          const result = nextProps.onTransitionStart(\n            this.transitionProps,\n            this.prevTransitionProps\n          );\n\n          // Wait for the onTransitionStart to resolve if needed.\n          if (result instanceof Promise) {\n            await result;\n          }\n        }\n\n        // get the transition spec.\n        const transitionUserSpec = nextProps.configureTransition\n          ? nextProps.configureTransition(\n              this.transitionProps,\n              this.prevTransitionProps\n            )\n          : null;\n\n        const transitionSpec = {\n          ...DefaultTransitionSpec,\n          ...transitionUserSpec,\n        };\n\n        const { timing } = transitionSpec;\n        delete transitionSpec.timing;\n\n        // if swiped back, indexHasChanged == true && positionHasChanged == false\n        // @ts-ignore\n        const positionHasChanged = position.__getValue() !== toValue;\n        if (indexHasChanged && positionHasChanged) {\n          timing(position, {\n            ...transitionSpec,\n            toValue: nextProps.navigation.state.index,\n          }).start(() => {\n            // In case the animation is immediately interrupted for some reason,\n            // we move this to the next frame so that onTransitionStart can fire\n            // first (https://github.com/react-navigation/react-navigation/issues/5247)\n            requestAnimationFrame(this.handleTransitionEnd);\n          });\n        } else {\n          this.handleTransitionEnd();\n        }\n      });\n    }\n  }\n\n  render() {\n    return (\n      <View onLayout={this.handleLayout} style={styles.main}>\n        {this.props.render(this.transitionProps, this.prevTransitionProps)}\n      </View>\n    );\n  }\n\n  private handleLayout = (event: LayoutChangeEvent) => {\n    const { height, width } = event.nativeEvent.layout;\n    if (\n      this.state.layout.initWidth === width &&\n      this.state.layout.initHeight === height\n    ) {\n      return;\n    }\n    const layout: TransitionerLayout = {\n      ...this.state.layout,\n      initHeight: height,\n      initWidth: width,\n      isMeasured: true,\n    };\n\n    layout.height.setValue(height);\n    layout.width.setValue(width);\n\n    const nextState = {\n      ...this.state,\n      layout,\n    };\n\n    this.transitionProps = buildTransitionProps(this.props, nextState);\n    this.setState(nextState);\n  };\n\n  private handleTransitionEnd = () => {\n    if (!this.isComponentMounted) {\n      return;\n    }\n    const prevTransitionProps = this.prevTransitionProps;\n    this.prevTransitionProps = undefined;\n\n    const scenes = filterStale(this.state.scenes);\n\n    const nextState = {\n      ...this.state,\n      scenes,\n    };\n\n    this.transitionProps = buildTransitionProps(this.props, nextState);\n\n    this.setState(nextState, async () => {\n      if (this.props.onTransitionEnd) {\n        const result = this.props.onTransitionEnd(\n          this.transitionProps,\n          prevTransitionProps\n        );\n\n        if (result instanceof Promise) {\n          await result;\n        }\n      }\n\n      if (this.queuedTransition) {\n        let { prevProps } = this.queuedTransition;\n        this.queuedTransition = null;\n        this.startTransition(prevProps, this.props);\n      } else {\n        this.isTransitionRunning = false;\n      }\n    });\n  };\n}\n\nfunction buildTransitionProps(props: Props, state: State): TransitionProps {\n  const { navigation } = props;\n\n  const { layout, position, scenes } = state;\n\n  const scene = scenes.find(isSceneActive);\n\n  if (!scene) {\n    throw new Error('Could not find active scene');\n  }\n\n  return {\n    layout,\n    navigation,\n    position,\n    scenes,\n    scene,\n    index: scene.index,\n  };\n}\n\nfunction isSceneNotStale(scene: Scene) {\n  return !scene.isStale;\n}\n\nfunction filterStale(scenes: Scene[]) {\n  const filtered = scenes.filter(isSceneNotStale);\n  if (filtered.length === scenes.length) {\n    return scenes;\n  }\n  return filtered;\n}\n\nfunction isSceneActive(scene: Scene) {\n  return scene.isActive;\n}\n\nconst styles = StyleSheet.create({\n  main: {\n    flex: 1,\n  },\n});\n\nexport default Transitioner;\n"]},"metadata":{},"sourceType":"module"}