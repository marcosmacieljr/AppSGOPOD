{"ast":null,"code":"import Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport getSceneIndicesForInterpolationInputRange from \"../../utils/getSceneIndicesForInterpolationInputRange\";\n\nfunction hasHeader(scene) {\n  if (!scene) {\n    return true;\n  }\n\n  var _scene$descriptor$opt = scene.descriptor.options,\n      header = _scene$descriptor$opt.header,\n      headerShown = _scene$descriptor$opt.headerShown;\n  return header !== null && headerShown !== false;\n}\n\nvar crossFadeInterpolation = function crossFadeInterpolation(scenes, first, index, last) {\n  return {\n    inputRange: [first, first + 0.001, index - 0.9, index - 0.2, index, last - 0.001, last],\n    outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, 0],\n    extrapolate: 'clamp'\n  };\n};\n\nfunction isGoingBack(scenes) {\n  var lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props) {\n  var layout = props.layout,\n      position = props.position,\n      scene = props.scene,\n      scenes = props.scenes,\n      mode = props.mode;\n\n  if (mode !== 'float') {\n    return {};\n  }\n\n  var isBack = isGoingBack(scenes);\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var width = layout.initWidth || Dimensions.get('window').width;\n\n  if (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last]) || !isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index])) {\n    return {\n      transform: [{\n        translateX: width\n      }]\n    };\n  }\n\n  var rtlMult = I18nManager.isRTL ? -1 : 1;\n  var translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [rtlMult * (hasHeader(scenes[first]) ? 0 : width), rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width), rtlMult * (hasHeader(scenes[last]) ? 0 : -width)],\n    extrapolate: 'clamp'\n  });\n  return {\n    transform: [{\n      translateX: translateX\n    }]\n  };\n}\n\nfunction forLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forLeftButton(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var inputRange = [first, first + 0.001, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last - 0.001, last];\n  var outputRange = [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.3 : 1, hasHeader(scenes[last]) ? 0 : 1, 0];\n  return {\n    opacity: position.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange,\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = LEFT_LABEL_OFFSET;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.35, index, index + 0.5, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.5 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset * 1.5, hasHeader(scenes[first]) ? -offset * 1.5 : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset * 1.5 : 0, -offset * 1.5],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = TITLE_OFFSET_IOS;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.5, index, index + 0.7, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset, hasHeader(scenes[first]) ? -offset : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset : 0, -offset],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nfunction forBackgroundWithFade(props) {\n  var position = props.position,\n      scene = props.scene;\n  var sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return {\n    opacity: 0\n  };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar VISIBLE = {\n  opacity: 1\n};\nvar HIDDEN = {\n  opacity: 0\n};\n\nfunction forBackgroundWithInactiveHidden(_ref) {\n  var navigation = _ref.navigation,\n      scene = _ref.scene;\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\nvar BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = BACKGROUND_OFFSET;\n  var outputRange = [offset, 0, -offset];\n  return {\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar forBackground = forBackgroundWithInactiveHidden;\nexport default {\n  forLayout: forLayout,\n  forLeft: forLeft,\n  forLeftButton: forLeftButton,\n  forLeftLabel: forLeftLabel,\n  forCenterFromLeft: forCenterFromLeft,\n  forCenter: forCenter,\n  forRight: forRight,\n  forBackground: forBackground,\n  forBackgroundWithInactiveHidden: forBackgroundWithInactiveHidden,\n  forBackgroundWithFade: forBackgroundWithFade,\n  forBackgroundWithTranslation: forBackgroundWithTranslation\n};","map":{"version":3,"mappings":"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","names":["getSceneIndicesForInterpolationInputRange","hasHeader","scene","descriptor","options","header","headerShown","crossFadeInterpolation","scenes","first","index","last","inputRange","outputRange","extrapolate","isGoingBack","lastSceneIndexInScenes","length","isActive","forLayout","props","layout","position","mode","isBack","interpolate","width","initWidth","Dimensions","get","transform","translateX","rtlMult","I18nManager","isRTL","forLeft","opacity","forCenter","forRight","forLeftButton","Math","abs","LEFT_LABEL_OFFSET","forLeftLabel","offset","TITLE_OFFSET_IOS","forCenterFromLeft","forBackgroundWithFade","sceneRange","VISIBLE","HIDDEN","forBackgroundWithInactiveHidden","navigation","state","BACKGROUND_OFFSET","forBackgroundWithTranslation","reverse","forBackground"],"sources":["HeaderStyleInterpolator.tsx"],"sourcesContent":["import { Dimensions, I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\nimport { Scene, SceneInterpolatorProps } from '../../types';\n\nfunction hasHeader(scene: Scene) {\n  if (!scene) {\n    return true;\n  }\n  const { header, headerShown } = scene.descriptor.options;\n\n  return header !== null && headerShown !== false;\n}\n\nconst crossFadeInterpolation = (\n  scenes: Scene[],\n  first: number,\n  index: number,\n  last: number\n): { inputRange: number[]; outputRange: number[]; extrapolate: 'clamp' } => ({\n  inputRange: [\n    first,\n    first + 0.001,\n    index - 0.9,\n    index - 0.2,\n    index,\n    last - 0.001,\n    last,\n  ],\n  outputRange: [\n    0,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0.3 : 1,\n    hasHeader(scenes[index]) ? 1 : 0,\n    hasHeader(scenes[last]) ? 0 : 1,\n    0,\n  ],\n  extrapolate: 'clamp',\n});\n\n/**\n * Utilities that build the style for the navigation header.\n *\n * +-------------+-------------+-------------+\n * |             |             |             |\n * |    Left     |   Title     |   Right     |\n * |  Component  |  Component  | Component   |\n * |             |             |             |\n * +-------------+-------------+-------------+\n */\n\nfunction isGoingBack(scenes: Scene[]) {\n  const lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props: SceneInterpolatorProps) {\n  const { layout, position, scene, scenes, mode } = props;\n  if (mode !== 'float') {\n    return {};\n  }\n  const isBack = isGoingBack(scenes);\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // We really shouldn't render the scene at all until we know the width of the\n  // stack. That said, in every case that I have ever seen, this has just been\n  // the full width of the window. This won't continue to be true if we support\n  // layouts like iPad master-detail. For now, in order to solve\n  // https://github.com/react-navigation/react-navigation/issues/4264, I have\n  // opted for the heuristic that we will use the window width until we have\n  // measured (and they will usually be the same).\n  const width = layout.initWidth || Dimensions.get('window').width;\n\n  // Make sure the header stays hidden when transitioning between 2 screens\n  // with no header.\n  if (\n    (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last])) ||\n    (!isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index]))\n  ) {\n    return {\n      transform: [{ translateX: width }],\n    };\n  }\n\n  const rtlMult = I18nManager.isRTL ? -1 : 1;\n  const translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [\n      rtlMult * (hasHeader(scenes[first]) ? 0 : width),\n      rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width),\n      rtlMult * (hasHeader(scenes[last]) ? 0 : -width),\n    ],\n    extrapolate: 'clamp',\n  });\n\n  return {\n    transform: [{ translateX }],\n  };\n}\n\nfunction forLeft(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\nfunction forCenter(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\nfunction forRight(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(\n      crossFadeInterpolation(scenes, first, index, last)\n    ),\n  };\n}\n\n/**\n * iOS UINavigationController style interpolators\n */\n\nfunction forLeftButton(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // The gist of what we're doing here is animating the left button _normally_ (fast fade)\n  // when both scenes in transition have headers. When the current, next, or previous scene _don't_\n  // have a header, we don't fade the button, and only set it's opacity to 0 at the last moment\n  // of the transition.\n  const inputRange = [\n    first,\n    first + 0.001,\n    first + Math.abs(index - first) / 2,\n    index,\n    last - Math.abs(last - index) / 2,\n    last - 0.001,\n    last,\n  ];\n  const outputRange = [\n    0,\n    hasHeader(scenes[first]) ? 0 : 1,\n    hasHeader(scenes[first]) ? 0.3 : 1,\n    hasHeader(scenes[index]) ? 1 : 0,\n    hasHeader(scenes[last]) ? 0.3 : 1,\n    hasHeader(scenes[last]) ? 0 : 1,\n    0,\n  ];\n\n  return {\n    opacity: position.interpolate({\n      inputRange,\n      outputRange,\n      extrapolate: 'clamp',\n    }),\n  };\n}\n\n/*\n * NOTE: this offset calculation is an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. See the comment on title for more information.\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  const offset = LEFT_LABEL_OFFSET;\n\n  // Similarly to the animation of the left label, when animating to or from a scene without\n  // a header, we keep the label at full opacity and in the same position for as long as possible.\n  return {\n    // For now we fade out the label before fading in the title, so the\n    // differences between the label and title position can be hopefully not so\n    // noticable to the user\n    opacity: position.interpolate({\n      inputRange: [\n        first,\n        first + 0.001,\n        index - 0.35,\n        index,\n        index + 0.5,\n        last - 0.001,\n        last,\n      ],\n      outputRange: [\n        0,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[index]) ? 1 : 0,\n        hasHeader(scenes[last]) ? 0.5 : 1,\n        hasHeader(scenes[last]) ? 0 : 1,\n        0,\n      ],\n      extrapolate: 'clamp',\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, first + 0.001, index, last - 0.001, last],\n          outputRange: I18nManager.isRTL\n            ? [\n                -offset * 1.5,\n                hasHeader(scenes[first]) ? -offset * 1.5 : 0,\n                0,\n                hasHeader(scenes[last]) ? offset : 0,\n                offset,\n              ]\n            : [\n                offset,\n                hasHeader(scenes[first]) ? offset : 0,\n                0,\n                hasHeader(scenes[last]) ? -offset * 1.5 : 0,\n                -offset * 1.5,\n              ],\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n/*\n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. We want the back button label to transition\n * smoothly into the title text and to do this we need to understand\n * where the title is positioned within the title container (since it is\n * centered).\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props: SceneInterpolatorProps) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = TITLE_OFFSET_IOS;\n\n  return {\n    opacity: position.interpolate({\n      inputRange: [\n        first,\n        first + 0.001,\n        index - 0.5,\n        index,\n        index + 0.7,\n        last - 0.001,\n        last,\n      ],\n      outputRange: [\n        0,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[first]) ? 0 : 1,\n        hasHeader(scenes[index]) ? 1 : 0,\n        hasHeader(scenes[last]) ? 0 : 1,\n        hasHeader(scenes[last]) ? 0 : 1,\n        0,\n      ],\n      extrapolate: 'clamp',\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, first + 0.001, index, last - 0.001, last],\n          outputRange: I18nManager.isRTL\n            ? [\n                -offset,\n                hasHeader(scenes[first]) ? -offset : 0,\n                0,\n                hasHeader(scenes[last]) ? offset : 0,\n                offset,\n              ]\n            : [\n                offset,\n                hasHeader(scenes[first]) ? offset : 0,\n                0,\n                hasHeader(scenes[last]) ? -offset : 0,\n                -offset,\n              ],\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n// Fade in background of header while transitioning\nfunction forBackgroundWithFade(props: SceneInterpolatorProps) {\n  const { position, scene } = props;\n  const sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return { opacity: 0 };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp',\n    }),\n  };\n}\n\nconst VISIBLE = { opacity: 1 };\nconst HIDDEN = { opacity: 0 };\n\n// Toggle visibility of header without fading\nfunction forBackgroundWithInactiveHidden({\n  navigation,\n  scene,\n}: SceneInterpolatorProps) {\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\n// Translate the background with the card\nconst BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props: SceneInterpolatorProps) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = BACKGROUND_OFFSET;\n  const outputRange = [offset, 0, -offset];\n  return {\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, index, last],\n          outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n          extrapolate: 'clamp',\n        }),\n      },\n    ],\n  };\n}\n\n// Default to fade transition\nconst forBackground = forBackgroundWithInactiveHidden;\n\nexport default {\n  forLayout,\n  forLeft,\n  forLeftButton,\n  forLeftLabel,\n  forCenterFromLeft,\n  forCenter,\n  forRight,\n  forBackground,\n  forBackgroundWithInactiveHidden,\n  forBackgroundWithFade,\n  forBackgroundWithTranslation,\n};\n"]},"metadata":{},"sourceType":"module"}