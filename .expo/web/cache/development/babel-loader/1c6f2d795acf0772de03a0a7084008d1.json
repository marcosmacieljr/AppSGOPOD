{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  var nextRoutes = nextState.routes;\n\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    var prevRoutes = prevState.routes;\n\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n\n    prevRoutes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      });\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread({}, scene, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\"There should always be only one scene active, not \" + activeScenesCount + \".\");\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n\n  return scenes;\n}","map":{"version":3,"mappings":"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","names":["shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","Error","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"sources":["ScenesReducer.tsx"],"sourcesContent":["import shallowEqual from '../utils/shallowEqual';\nimport { Scene, NavigationStackState, SceneDescriptorMap } from '../types';\nimport { NavigationRoute } from 'react-navigation';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: Scene, two: Scene) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one: Scene, two: Scene) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one: NavigationRoute, two: NavigationRoute) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Scene[],\n  nextState: NavigationStackState,\n  prevState: NavigationStackState | null,\n  descriptors: SceneDescriptorMap\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene: Scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\n        `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n          'another route!'\n      );\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes: Scene[] = [];\n\n  const mergeScene = (nextScene: Scene) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\n      `There should always be only one scene active, not ${activeScenesCount}.`\n    );\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]},"metadata":{},"sourceType":"module"}