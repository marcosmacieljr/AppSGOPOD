{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport getChildRouter from \"./getChildRouter\";\nimport getNavigationActionCreators from \"./routers/getNavigationActionCreators\";\nimport getChildrenNavigationCache from \"./getChildrenNavigationCache\";\nimport getEventManager from \"./getEventManager\";\n\nvar createParamGetter = function createParamGetter(route) {\n  return function (paramName, defaultValue) {\n    var params = route.params;\n\n    if (params && paramName in params) {\n      return params[paramName];\n    }\n\n    return defaultValue;\n  };\n};\n\nfunction _getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  var children = getChildrenNavigationCache(navigation);\n  var childRoute = navigation.state.routes.find(function (r) {\n    return r.key === childKey;\n  });\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  var childRouter = getChildRouter(navigation.router, childRoute.routeName);\n  var focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;\n\n  var actionCreators = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, navigation.actions), navigation.router.getActionCreators(childRoute, navigation.state.key)), childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}), getNavigationActionCreators(childRoute));\n\n  var actionHelpers = {};\n  Object.keys(actionCreators).forEach(function (actionName) {\n    actionHelpers[actionName] = function () {\n      var actionCreator = actionCreators[actionName];\n      var action = actionCreator.apply(void 0, arguments);\n      return navigation.dispatch(action);\n    };\n  });\n  var _isFirstRouteInParent = true;\n  var parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    _isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (children[childKey] && children[childKey].isFirstRouteInParent() === _isFirstRouteInParent) {\n    children[childKey] = _objectSpread(_objectSpread(_objectSpread({}, children[childKey]), actionHelpers), {}, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute)\n    });\n    return children[childKey];\n  } else {\n    var _getEventManager = getEventManager(childKey),\n        addListener = _getEventManager.addListener,\n        emit = _getEventManager.emit;\n\n    children[childKey] = _objectSpread(_objectSpread({}, actionHelpers), {}, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n      getChildNavigation: function getChildNavigation(grandChildKey) {\n        return _getChildNavigation(children[childKey], grandChildKey, function () {\n          var nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        });\n      },\n      isFocused: function isFocused() {\n        var currentNavigation = getCurrentParentNavigation();\n\n        if (!currentNavigation) {\n          return false;\n        }\n\n        var _currentNavigation$st = currentNavigation.state,\n            routes = _currentNavigation$st.routes,\n            index = _currentNavigation$st.index;\n\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n\n        if (routes[index].key === childKey) {\n          return true;\n        }\n\n        return false;\n      },\n      isFirstRouteInParent: function isFirstRouteInParent() {\n        return _isFirstRouteInParent;\n      },\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener: addListener,\n      emit: emit\n    });\n    return children[childKey];\n  }\n}\n\nexport default _getChildNavigation;","map":{"version":3,"mappings":"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","names":["getChildRouter","getNavigationActionCreators","getChildrenNavigationCache","getEventManager","createParamGetter","route","paramName","defaultValue","params","getChildNavigation","navigation","childKey","getCurrentParentNavigation","children","childRoute","state","routes","find","r","key","childRouter","router","routeName","focusedGrandChildRoute","index","actionCreators","actions","getActionCreators","actionHelpers","Object","keys","forEach","actionName","actionCreator","action","dispatch","isFirstRouteInParent","parentNavigation","indexOf","getParam","addListener","emit","grandChildKey","nav","isFocused","currentNavigation","getScreenProps","dangerouslyGetParent"],"sources":["getChildNavigation.js"],"sourcesContent":["import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\n\nconst createParamGetter = (route) => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find((r) => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName);\n\n  // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n  const focusedGrandChildRoute =\n    childRoute.routes && typeof childRoute.index === 'number'\n      ? childRoute.routes[childRoute.index]\n      : null;\n\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter\n      ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)\n      : {}),\n    ...getNavigationActionCreators(childRoute),\n  };\n\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach((actionName) => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n\n  let isFirstRouteInParent = true;\n\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent =\n      parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (\n    children[childKey] &&\n    children[childKey].isFirstRouteInParent() === isFirstRouteInParent\n  ) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n    };\n    return children[childKey];\n  } else {\n    const { addListener, emit } = getEventManager(childKey);\n\n    children[childKey] = {\n      ...actionHelpers,\n\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n\n      getChildNavigation: (grandChildKey) =>\n        getChildNavigation(children[childKey], grandChildKey, () => {\n          const nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        }),\n\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const { routes, index } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit,\n    };\n\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;\n"]},"metadata":{},"sourceType":"module"}