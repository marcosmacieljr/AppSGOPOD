{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { DEVICE_CONNECTIVITY_EVENT } from \"./privateTypes\";\nimport { NetInfoStateType, NetInfoCellularGeneration } from \"./types\";\nvar connection = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\nvar typeMapping = {\n  bluetooth: NetInfoStateType.bluetooth,\n  cellular: NetInfoStateType.cellular,\n  ethernet: NetInfoStateType.ethernet,\n  none: NetInfoStateType.none,\n  other: NetInfoStateType.other,\n  unknown: NetInfoStateType.unknown,\n  wifi: NetInfoStateType.wifi,\n  wimax: NetInfoStateType.wimax,\n  mixed: NetInfoStateType.other\n};\nvar effectiveTypeMapping = {\n  '2g': NetInfoCellularGeneration['2g'],\n  '3g': NetInfoCellularGeneration['3g'],\n  '4g': NetInfoCellularGeneration['4g'],\n  'slow-2g': NetInfoCellularGeneration['2g']\n};\n\nvar _getCurrentState = function getCurrentState(_requestedInterface) {\n  var isConnected = navigator.onLine;\n  var baseState = {\n    isInternetReachable: null\n  };\n\n  if (!connection) {\n    if (isConnected) {\n      var _state2 = _objectSpread(_objectSpread({}, baseState), {}, {\n        isConnected: true,\n        type: NetInfoStateType.other,\n        details: {\n          isConnectionExpensive: false\n        }\n      });\n\n      return _state2;\n    }\n\n    var _state = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: false,\n      isInternetReachable: false,\n      type: NetInfoStateType.none,\n      details: null\n    });\n\n    return _state;\n  }\n\n  var isConnectionExpensive = connection.saveData;\n  var type = connection.type ? typeMapping[connection.type] : isConnected ? NetInfoStateType.other : NetInfoStateType.unknown;\n\n  if (type === NetInfoStateType.bluetooth) {\n    var _state3 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive\n      }\n    });\n\n    return _state3;\n  } else if (type === NetInfoStateType.cellular) {\n    var _state4 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        cellularGeneration: effectiveTypeMapping[connection.effectiveType] || null,\n        carrier: null\n      }\n    });\n\n    return _state4;\n  } else if (type === NetInfoStateType.ethernet) {\n    var _state5 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        ipAddress: null,\n        subnet: null\n      }\n    });\n\n    return _state5;\n  } else if (type === NetInfoStateType.wifi) {\n    var _state6 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        ssid: null,\n        bssid: null,\n        strength: null,\n        ipAddress: null,\n        subnet: null,\n        frequency: null\n      }\n    });\n\n    return _state6;\n  } else if (type === NetInfoStateType.wimax) {\n    var _state7 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive\n      }\n    });\n\n    return _state7;\n  } else if (type === NetInfoStateType.none) {\n    var _state8 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: false,\n      isInternetReachable: false,\n      type: type,\n      details: null\n    });\n\n    return _state8;\n  } else if (type === NetInfoStateType.unknown) {\n    var _state9 = _objectSpread(_objectSpread({}, baseState), {}, {\n      isConnected: isConnected,\n      isInternetReachable: null,\n      type: type,\n      details: null\n    });\n\n    return _state9;\n  }\n\n  var state = _objectSpread(_objectSpread({}, baseState), {}, {\n    isConnected: true,\n    type: NetInfoStateType.other,\n    details: {\n      isConnectionExpensive: isConnectionExpensive\n    }\n  });\n\n  return state;\n};\n\nvar handlers = [];\nvar nativeHandlers = [];\nvar RNCNetInfo = {\n  addListener: function addListener(type, handler) {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT:\n        {\n          var nativeHandler = function nativeHandler() {\n            handler(_getCurrentState());\n          };\n\n          if (connection) {\n            connection.addEventListener('change', nativeHandler);\n          } else {\n            window.addEventListener('online', nativeHandler, false);\n            window.addEventListener('offline', nativeHandler, false);\n          }\n\n          handlers.push(handler);\n          nativeHandlers.push(nativeHandler);\n          break;\n        }\n    }\n  },\n  removeListeners: function removeListeners(type, handler) {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT:\n        {\n          var index = handlers.indexOf(handler);\n          var nativeHandler = nativeHandlers[index];\n\n          if (connection) {\n            connection.removeEventListener('change', nativeHandler);\n          } else {\n            window.addEventListener('online', nativeHandler);\n            window.addEventListener('offline', nativeHandler);\n          }\n\n          handlers.splice(index, 1);\n          nativeHandlers.splice(index, 1);\n          break;\n        }\n    }\n  },\n  getCurrentState: function getCurrentState(requestedInterface) {\n    return function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _getCurrentState(requestedInterface));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  }\n};\nexport default RNCNetInfo;","map":{"version":3,"mappings":"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","names":["DEVICE_CONNECTIVITY_EVENT","NetInfoStateType","NetInfoCellularGeneration","connection","window","navigator","mozConnection","webkitConnection","typeMapping","bluetooth","cellular","ethernet","none","other","unknown","wifi","wimax","mixed","effectiveTypeMapping","getCurrentState","_requestedInterface","isConnected","onLine","baseState","isInternetReachable","state","type","details","isConnectionExpensive","saveData","cellularGeneration","effectiveType","carrier","ipAddress","subnet","ssid","bssid","strength","frequency","handlers","nativeHandlers","RNCNetInfo","addListener","handler","nativeHandler","addEventListener","push","removeListeners","index","indexOf","removeEventListener","splice","requestedInterface"],"sources":["nativeModule.web.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {\n  NetInfoNativeModule,\n  DEVICE_CONNECTIVITY_EVENT,\n  NetInfoNativeModuleState,\n} from './privateTypes';\nimport {\n  NetInfoState,\n  NetInfoStateType,\n  NetInfoUnknownState,\n  NetInfoNoConnectionState,\n  NetInfoCellularState,\n  NetInfoBluetoothState,\n  NetInfoEthernetState,\n  NetInfoWifiState,\n  NetInfoWimaxState,\n  NetInfoOtherState,\n  NetInfoCellularGeneration,\n} from './types';\n\n// See https://wicg.github.io/netinfo/#dom-connectiontype\ntype ConnectionType =\n  | 'bluetooth'\n  | 'cellular'\n  | 'ethernet'\n  | 'mixed'\n  | 'none'\n  | 'other'\n  | 'unknown'\n  | 'wifi'\n  | 'wimax';\n\n// See https://wicg.github.io/netinfo/#dom-effectiveconnectiontype\ntype ConnectionEffectiveType = '2g' | '3g' | '4g' | 'slow-2g';\n\n// https://wicg.github.io/netinfo/#dom-networkinformation-savedata\ntype ConnectionSaveData = boolean;\n\ninterface Events {\n  change: Event;\n}\n\ninterface Connection {\n  type: ConnectionType;\n  effectiveType: ConnectionEffectiveType;\n  saveData: ConnectionSaveData;\n  addEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n}\n\n// Create (optional) connection APIs on navigator\ndeclare global {\n  interface Navigator {\n    connection?: Connection;\n    mozConnection?: Connection;\n    webkitConnection?: Connection;\n  }\n}\n\n// Check if the browser supports the connection API\nconst connection =\n  window.navigator.connection ||\n  window.navigator.mozConnection ||\n  window.navigator.webkitConnection;\n\n// Map browser types to native types\nconst typeMapping: Record<ConnectionType, NetInfoStateType> = {\n  bluetooth: NetInfoStateType.bluetooth,\n  cellular: NetInfoStateType.cellular,\n  ethernet: NetInfoStateType.ethernet,\n  none: NetInfoStateType.none,\n  other: NetInfoStateType.other,\n  unknown: NetInfoStateType.unknown,\n  wifi: NetInfoStateType.wifi,\n  wimax: NetInfoStateType.wimax,\n  mixed: NetInfoStateType.other,\n};\nconst effectiveTypeMapping: Record<\n  ConnectionEffectiveType,\n  NetInfoCellularGeneration\n> = {\n  '2g': NetInfoCellularGeneration['2g'],\n  '3g': NetInfoCellularGeneration['3g'],\n  '4g': NetInfoCellularGeneration['4g'],\n  'slow-2g': NetInfoCellularGeneration['2g'],\n};\n\n// Determine current state of connection\nconst getCurrentState = (\n  _requestedInterface?: string,\n): Pick<NetInfoState, Exclude<keyof NetInfoState, 'isInternetReachable'>> => {\n  const isConnected = navigator.onLine;\n  const baseState = {\n    isInternetReachable: null,\n  };\n\n  // If we don't have a connection object, we return minimal information\n  if (!connection) {\n    if (isConnected) {\n      const state: NetInfoOtherState = {\n        ...baseState,\n        isConnected: true,\n        type: NetInfoStateType.other,\n        details: {\n          isConnectionExpensive: false,\n        },\n      };\n      return state;\n    }\n\n    const state: NetInfoNoConnectionState = {\n      ...baseState,\n      isConnected: false,\n      isInternetReachable: false,\n      type: NetInfoStateType.none,\n      details: null,\n    };\n    return state;\n  }\n\n  // Otherwise try to return detailed information\n  const isConnectionExpensive = connection.saveData;\n  const type: NetInfoStateType = connection.type\n    ? typeMapping[connection.type]\n    : isConnected\n    ? NetInfoStateType.other\n    : NetInfoStateType.unknown;\n\n  if (type === NetInfoStateType.bluetooth) {\n    const state: NetInfoBluetoothState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.cellular) {\n    const state: NetInfoCellularState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        cellularGeneration:\n          effectiveTypeMapping[connection.effectiveType] || null,\n        carrier: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.ethernet) {\n    const state: NetInfoEthernetState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        ipAddress: null,\n        subnet: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.wifi) {\n    const state: NetInfoWifiState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        ssid: null,\n        bssid: null,\n        strength: null,\n        ipAddress: null,\n        subnet: null,\n        frequency: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.wimax) {\n    const state: NetInfoWimaxState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.none) {\n    const state: NetInfoNoConnectionState = {\n      ...baseState,\n      isConnected: false,\n      isInternetReachable: false,\n      type,\n      details: null,\n    };\n    return state;\n  } else if (type === NetInfoStateType.unknown) {\n    const state: NetInfoUnknownState = {\n      ...baseState,\n      isConnected,\n      isInternetReachable: null,\n      type,\n      details: null,\n    };\n    return state;\n  }\n\n  const state: NetInfoOtherState = {\n    ...baseState,\n    isConnected: true,\n    type: NetInfoStateType.other,\n    details: {\n      isConnectionExpensive,\n    },\n  };\n  return state;\n};\n\nconst handlers: ((state: NetInfoNativeModuleState) => void)[] = [];\nconst nativeHandlers: (() => void)[] = [];\n\nconst RNCNetInfo: NetInfoNativeModule = {\n  addListener(type, handler): void {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT: {\n        const nativeHandler = (): void => {\n          handler(getCurrentState());\n        };\n\n        if (connection) {\n          connection.addEventListener('change', nativeHandler);\n        } else {\n          window.addEventListener('online', nativeHandler, false);\n          window.addEventListener('offline', nativeHandler, false);\n        }\n\n        // Remember handlers\n        handlers.push(handler);\n        nativeHandlers.push(nativeHandler);\n\n        break;\n      }\n    }\n  },\n\n  removeListeners(type, handler): void {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT: {\n        // Get native handler\n        const index = handlers.indexOf(handler);\n        const nativeHandler = nativeHandlers[index];\n\n        if (connection) {\n          connection.removeEventListener('change', nativeHandler);\n        } else {\n          window.addEventListener('online', nativeHandler);\n          window.addEventListener('offline', nativeHandler);\n        }\n\n        // Remove handlers\n        handlers.splice(index, 1);\n        nativeHandlers.splice(index, 1);\n\n        break;\n      }\n    }\n  },\n\n  async getCurrentState(requestedInterface): Promise<NetInfoNativeModuleState> {\n    return getCurrentState(requestedInterface);\n  },\n};\n\nexport default RNCNetInfo;\n"]},"metadata":{},"sourceType":"module"}