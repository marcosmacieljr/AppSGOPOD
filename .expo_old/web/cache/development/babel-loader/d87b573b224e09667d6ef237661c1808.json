{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport NetInfo from \"@react-native-community/netinfo\";\nimport axios from \"axios\";\nimport * as constants from \"./constants\";\nimport { newForm } from \"../db/forms\";\nexport var httpRequest = function httpRequest(json, route) {\n  var toReturn, netInfo, params;\n  return _regeneratorRuntime.async(function httpRequest$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          toReturn = false;\n          _context.prev = 1;\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(NetInfo.fetch());\n\n        case 4:\n          netInfo = _context.sent;\n\n          if (!netInfo.isConnected) {\n            _context.next = 15;\n            break;\n          }\n\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(urlParser(json));\n\n        case 8:\n          params = _context.sent;\n          console.log(route);\n          console.log(params + \"PARAMETROS\");\n          _context.next = 13;\n          return _regeneratorRuntime.awrap(axios.get(constants.appAddress + route + params, {\n            timeout: 30 * 1000\n          }).then(function (res) {\n            toReturn = res.data;\n          }).catch(function (err) {\n            if (err.code === 'ECONNABORTED' || err.code == undefined) {\n              toReturn = {\n                message: constants.timeoutMessage\n              };\n            } else {\n              toReturn = {\n                message: constants.errorMessage\n              };\n            }\n          }));\n\n        case 13:\n          _context.next = 16;\n          break;\n\n        case 15:\n          toReturn = {\n            message: constants.notConnectedMessage\n          };\n\n        case 16:\n          _context.next = 22;\n          break;\n\n        case 18:\n          _context.prev = 18;\n          _context.t0 = _context[\"catch\"](1);\n          console.log('Error no catch: ' + _context.t0);\n          toReturn = {\n            message: constants.errorMessage\n          };\n\n        case 22:\n          return _context.abrupt(\"return\", toReturn);\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[1, 18]], Promise);\n};\n\nvar urlParser = function urlParser(json) {\n  var toReturn;\n  return _regeneratorRuntime.async(function urlParser$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          toReturn = \"\";\n\n          if (Object.getOwnPropertyNames(json).length > 0) {\n            toReturn = \"?\";\n\n            for (key in json) {\n              if (json.hasOwnProperty(key)) {\n                toReturn += encodeURI(key) + \"=\" + encodeURI(json[key]);\n                console.log(encodeURI(key) + \" : \" + encodeURI(json[key]));\n              }\n\n              toReturn += \"&\";\n            }\n\n            toReturn = toReturn.slice(0, -1);\n          }\n\n          return _context2.abrupt(\"return\", toReturn);\n\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["C:/Repositorio/SgoApp/APP/utils/apiUtils.js"],"names":["NetInfo","axios","constants","newForm","httpRequest","json","route","toReturn","fetch","netInfo","isConnected","urlParser","params","console","log","get","appAddress","timeout","then","res","data","catch","err","code","undefined","message","timeoutMessage","errorMessage","notConnectedMessage","Object","getOwnPropertyNames","length","key","hasOwnProperty","encodeURI","slice"],"mappings":";AAAA,OAAOA,OAAP,MAAoB,iCAApB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAO,KAAKC,SAAZ;AACA,SAASC,OAAT;AAEA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAOC,IAAP,EAAaC,KAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAEtBC,UAAAA,QAFsB,GAEX,KAFW;AAAA;AAAA;AAAA,2CAKHP,OAAO,CAACQ,KAAR,EALG;;AAAA;AAKnBC,UAAAA,OALmB;;AAAA,eAOtBA,OAAO,CAACC,WAPc;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAQHC,SAAS,CAACN,IAAD,CARN;;AAAA;AAQlBO,UAAAA,MARkB;AASxBC,UAAAA,OAAO,CAACC,GAAR,CAAYR,KAAZ;AACAO,UAAAA,OAAO,CAACC,GAAR,CAAYF,MAAM,GAAG,YAArB;AAVwB;AAAA,2CAWlBX,KAAK,CAACc,GAAN,CAAUb,SAAS,CAACc,UAAV,GAAuBV,KAAvB,GAA+BM,MAAzC,EAAiD;AAACK,YAAAA,OAAO,EAAE,KAAK;AAAf,WAAjD,EAAuEC,IAAvE,CAA4E,UAAAC,GAAG,EAAI;AACxFZ,YAAAA,QAAQ,GAAGY,GAAG,CAACC,IAAf;AACA,WAFK,EAEHC,KAFG,CAEG,UAAAC,GAAG,EAAI;AACf,gBAAIA,GAAG,CAACC,IAAJ,KAAa,cAAb,IAA+BD,GAAG,CAACC,IAAJ,IAAYC,SAA/C,EAA0D;AACzDjB,cAAAA,QAAQ,GAAG;AAACkB,gBAAAA,OAAO,EAAEvB,SAAS,CAACwB;AAApB,eAAX;AACA,aAFD,MAEO;AACNnB,cAAAA,QAAQ,GAAG;AAACkB,gBAAAA,OAAO,EAAEvB,SAAS,CAACyB;AAApB,eAAX;AACA;AACD,WARK,CAXkB;;AAAA;AAAA;AAAA;;AAAA;AAqBxBpB,UAAAA,QAAQ,GAAG;AAACkB,YAAAA,OAAO,EAAEvB,SAAS,CAAC0B;AAApB,WAAX;;AArBwB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAwBzBf,UAAAA,OAAO,CAACC,GAAR,CAAY,gCAAZ;AACAP,UAAAA,QAAQ,GAAG;AAACkB,YAAAA,OAAO,EAAEvB,SAAS,CAACyB;AAApB,WAAX;;AAzByB;AAAA,2CA2BhBpB,QA3BgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAApB;;AA8BP,IAAMI,SAAS,GAAG,SAAZA,SAAY,CAAON,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACbE,UAAAA,QADa,GACF,EADE;;AAEjB,cAAGsB,MAAM,CAACC,mBAAP,CAA2BzB,IAA3B,EAAiC0B,MAAjC,GAA0C,CAA7C,EAA+C;AAC9CxB,YAAAA,QAAQ,GAAG,GAAX;;AACA,iBAAKyB,GAAL,IAAY3B,IAAZ,EAAkB;AACjB,kBAAIA,IAAI,CAAC4B,cAAL,CAAoBD,GAApB,CAAJ,EAA8B;AAC7BzB,gBAAAA,QAAQ,IAAI2B,SAAS,CAACF,GAAD,CAAT,GAAiB,GAAjB,GAAuBE,SAAS,CAAC7B,IAAI,CAAC2B,GAAD,CAAL,CAA5C;AACAnB,gBAAAA,OAAO,CAACC,GAAR,CAAYoB,SAAS,CAACF,GAAD,CAAT,GAAiB,KAAjB,GAAyBE,SAAS,CAAC7B,IAAI,CAAC2B,GAAD,CAAL,CAA9C;AACA;;AACDzB,cAAAA,QAAQ,IAAI,GAAZ;AACA;;AACDA,YAAAA,QAAQ,GAAGA,QAAQ,CAAC4B,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAX;AACA;;AAZgB,4CAaV5B,QAbU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAlB","sourcesContent":["import NetInfo from \"@react-native-community/netinfo\";\r\nimport axios from \"axios\";\r\nimport * as constants from './constants';\r\nimport { newForm } from '../db/forms';\r\n\r\nexport const httpRequest = async (json, route) => {\r\n\t\r\n\tlet toReturn = false;\r\n\r\n\ttry {\t\t\r\n\t\tconst netInfo = await NetInfo.fetch();\t\t\t\t\t\t\r\n\t\t//if(netInfo.isInternetReachable) { //antes era essa ssinatura ai parou de funcionar, saber por que esta retornando undefined\r\n\t\tif(netInfo.isConnected) {\t\t\t\t\t\t\r\n\t\t\tconst params = await urlParser(json);\t\t\t\t\t\t\r\n\t\t\tconsole.log(route); //mostrar a rota por onde esta passando no momento\r\n\t\t\tconsole.log(params + \"PARAMETROS\");\t//mostra os parametros que estÃ£o sendo passados\t\t\t\t\t\r\n\t\t\tawait axios.get(constants.appAddress + route + params, {timeout: 30 * 1000}).then(res => {\t\t\t\t\r\n\t\t\t\ttoReturn = res.data;\t\t\t\t\t\t\r\n\t\t\t}).catch(err => {\r\n\t\t\t\tif (err.code === 'ECONNABORTED' || err.code == undefined) {\t\t\t\t\t\r\n\t\t\t\t\ttoReturn = {message: constants.timeoutMessage};\r\n\t\t\t\t} else {\t\t\t\t\t\r\n\t\t\t\t\ttoReturn = {message: constants.errorMessage};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\t\t\t\r\n\t\t\ttoReturn = {message: constants.notConnectedMessage};\r\n\t\t}\r\n    } catch (error) {\r\n\t\tconsole.log('Error no catch: ' + error);\r\n\t\ttoReturn = {message: constants.errorMessage};\r\n\t}\t\r\n    return toReturn;\r\n}\r\n\r\nconst urlParser = async (json) => {\r\n\tlet toReturn = \"\";\r\n\tif(Object.getOwnPropertyNames(json).length > 0){\r\n\t\ttoReturn = \"?\";\r\n\t\tfor (key in json) {\r\n\t\t\tif (json.hasOwnProperty(key)) {\t\t\t\t\t\t\t\t\r\n\t\t\t\ttoReturn += encodeURI(key) + \"=\" + encodeURI(json[key]);\r\n\t\t\t\tconsole.log(encodeURI(key) + \" : \" + encodeURI(json[key])); //mostra no console as keys e valores passados pelo JSON\r\n\t\t\t}\r\n\t\t\ttoReturn += \"&\";\r\n\t\t}\r\n\t\ttoReturn = toReturn.slice(0, -1);\r\n\t}\r\n\treturn toReturn;\r\n}"]},"metadata":{},"sourceType":"module"}